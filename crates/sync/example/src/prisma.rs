// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
pub static DATAMODEL_STR : & 'static str = include_str ! ("/Users/brendonovich/github.com/spacedriveapp/spacedrive/crates/sync/example-2/prisma/schema.prisma") ;
static DATABASE_STR: &'static str = "sqlite";
use ::prisma_client_rust::migrations::include_dir;
pub static MIGRATIONS_DIR : & :: prisma_client_rust :: migrations :: include_dir :: Dir = & :: prisma_client_rust :: migrations :: include_dir :: include_dir ! ("/Users/brendonovich/github.com/spacedriveapp/spacedrive/crates/sync/example-2/prisma/migrations") ;
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	let config = ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?.subject;
	let source = config
		.datasources
		.first()
		.expect("Please supply a datasource in your schema.prisma file");
	let url = if let Some(url) = source.load_shadow_database_url()? {
		url
	} else {
		source.load_url(|key| std::env::var(key).ok())?
	};
	let url = if url.starts_with("file:") {
		let path = url.split(":").nth(1).unwrap();
		if std::path::Path::new("./schema.prisma").exists() {
			url
		} else if std::path::Path::new("./prisma/schema.prisma").exists() {
			format!("file:./prisma/{}", path)
		} else {
			url
		}
	} else {
		url
	};
	new_client_with_url(&url).await
}
pub async fn new_client_with_url(
	url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	let config = ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?.subject;
	let source = config
		.datasources
		.first()
		.expect("Please supply a datasource in your schema.prisma file");
	let (db_name, executor) =
		::prisma_client_rust::query_core::executor::load(&source, &[], &url).await?;
	let internal_model =
		::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(DATAMODEL_STR)
			.build(db_name);
	let query_schema = std::sync::Arc::new(prisma_client_rust::query_core::schema_builder::build(
		internal_model,
		true,
		source.capabilities(),
		vec![],
		source.referential_integrity(),
	));
	executor.primary_connector().get_connection().await?;
	let url = url.to_string();
	Ok(PrismaClient::_new(executor, query_schema, url))
}
pub mod user {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::IdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::IdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::IdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::IdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::IdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
	}
	pub mod name {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::NameEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Name(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::NameInVec(value)
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::NameNotInVec(value)
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::NameLt(value)
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::NameLte(value)
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::NameGt(value)
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::NameGte(value)
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::NameContains(value)
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::NameStartsWith(value)
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::NameEndsWith(value)
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::NameNot(value)
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetName(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("name").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("name").build()
			}
		}
	}
	pub mod email {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::EmailEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Email(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::EmailInVec(value)
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::EmailNotInVec(value)
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::EmailLt(value)
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::EmailLte(value)
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::EmailGt(value)
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::EmailGte(value)
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::EmailContains(value)
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::EmailStartsWith(value)
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::EmailEndsWith(value)
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::EmailNot(value)
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetEmail(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Email(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("email").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Email(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("email").build()
			}
		}
	}
	pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
		["id", "name", "email"]
			.into_iter()
			.map(|o| {
				let builder = ::prisma_client_rust::Selection::builder(o);
				builder.build()
			})
			.collect()
	}
	pub fn create(
		name: String,
		email: String,
		_params: Vec<SetParam>,
	) -> (String, String, Vec<SetParam>) {
		(name, email, _params)
	}
	pub fn create_unchecked(
		name: String,
		email: String,
		_params: Vec<SetParam>,
	) -> (String, String, Vec<SetParam>) {
		(name, email, _params)
	}
	#[macro_export]
	macro_rules ! _select_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , email } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "email"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [$ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; email) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "User" , available fields are "id, name, email")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: name :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: email :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; email) => { "email" } ; }
	pub use _select_user as select;
	pub enum SelectParam {
		Id(id::Select),
		Name(name::Select),
		Email(email::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Email(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: user :: _outputs () ; selections . extend ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: user :: _outputs () ; selections . extend ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub name : String , pub email : String , $ (pub $ field : $ crate :: prisma :: user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (email)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; email) , & self . email) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , email } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; email) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; email) => Ok (Field :: email) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut email = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; email))) ; } email = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; name))) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; email))) ? ; Ok (Data { id , name , email , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "email"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (id) . to_string () , optional : false , ty : < i32 as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (name) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (email) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , $ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; email) => { "email" } ; }
	pub use _include_user as include;
	pub enum IncludeParam {
		Id(id::Include),
		Name(name::Include),
		Email(email::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Email(data) => data.to_selection(),
			}
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: rspc :: Type,
	)]
	#[specta(rename = "User", crate = "prisma_client_rust::rspc::internal::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "email")]
		pub email: String,
	}
	impl Data {}
	#[derive(Clone)]
	pub enum WithParam {}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i32),
		IncrementId(i32),
		DecrementId(i32),
		MultiplyId(i32),
		DivideId(i32),
		SetName(String),
		SetEmail(String),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetName(value) => (
					"name".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::SetEmail(value) => (
					"email".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(::prisma_client_rust::Direction),
		Name(::prisma_client_rust::Direction),
		Email(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Id(direction) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Name(direction) => (
					"name".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Email(direction) => (
					"email".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(i32),
		IdInVec(Vec<i32>),
		IdNotInVec(Vec<i32>),
		IdLt(i32),
		IdLte(i32),
		IdGt(i32),
		IdGte(i32),
		IdNot(i32),
		NameEquals(String),
		NameInVec(Vec<String>),
		NameNotInVec(Vec<String>),
		NameLt(String),
		NameLte(String),
		NameGt(String),
		NameGte(String),
		NameContains(String),
		NameStartsWith(String),
		NameEndsWith(String),
		NameNot(String),
		EmailEquals(String),
		EmailInVec(Vec<String>),
		EmailNotInVec(Vec<String>),
		EmailLt(String),
		EmailLte(String),
		EmailGt(String),
		EmailGte(String),
		EmailContains(String),
		EmailStartsWith(String),
		EmailEndsWith(String),
		EmailNot(String),
	}
	impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
		fn into(self) -> ::prisma_client_rust::SerializedWhere {
			match self {
				Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						value
							.into_iter()
							.map(Into::<::prisma_client_rust::SerializedWhere>::into)
							.map(Into::into)
							.collect(),
					),
				),
				Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(Into::<::prisma_client_rust::SerializedWhere>::into)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						value
							.into_iter()
							.map(Into::<::prisma_client_rust::SerializedWhere>::into)
							.map(Into::into)
							.collect(),
					),
				),
				Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"in".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::NameEquals(value) => ::prisma_client_rust::SerializedWhere::new(
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::NameInVec(value) => ::prisma_client_rust::SerializedWhere::new(
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"in".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::String(v))
								.collect(),
						),
					)]),
				),
				Self::NameNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::String(v))
								.collect(),
						),
					)]),
				),
				Self::NameLt(value) => ::prisma_client_rust::SerializedWhere::new(
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::NameLte(value) => ::prisma_client_rust::SerializedWhere::new(
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::NameGt(value) => ::prisma_client_rust::SerializedWhere::new(
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::NameGte(value) => ::prisma_client_rust::SerializedWhere::new(
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::NameContains(value) => ::prisma_client_rust::SerializedWhere::new(
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"contains".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::NameStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"startsWith".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::NameEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"endsWith".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::NameNot(value) => ::prisma_client_rust::SerializedWhere::new(
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::EmailEquals(value) => ::prisma_client_rust::SerializedWhere::new(
					"email",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::EmailInVec(value) => ::prisma_client_rust::SerializedWhere::new(
					"email",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"in".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::String(v))
								.collect(),
						),
					)]),
				),
				Self::EmailNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
					"email",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::String(v))
								.collect(),
						),
					)]),
				),
				Self::EmailLt(value) => ::prisma_client_rust::SerializedWhere::new(
					"email",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::EmailLte(value) => ::prisma_client_rust::SerializedWhere::new(
					"email",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::EmailGt(value) => ::prisma_client_rust::SerializedWhere::new(
					"email",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::EmailGte(value) => ::prisma_client_rust::SerializedWhere::new(
					"email",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::EmailContains(value) => ::prisma_client_rust::SerializedWhere::new(
					"email",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"contains".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::EmailStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
					"email",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"startsWith".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::EmailEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
					"email",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"endsWith".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::EmailNot(value) => ::prisma_client_rust::SerializedWhere::new(
					"email",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		EmailEquals(String),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::EmailEquals(value) => Self::EmailEquals(value),
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
	pub type ManyArgs =
		::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
	pub type Count<'a> =
		::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
	pub type FindUnique<'a> =
		::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		UniqueWhereParam,
		SetParam,
		Data,
	>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		UniqueWhereParam,
		Data,
	>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
	pub struct Actions<'a> {
		pub client: &'a PrismaClient,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where.into(),
			)
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where,
			)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where,
			)
		}
		pub fn create(self, name: String, email: String, mut _params: Vec<SetParam>) -> Create<'a> {
			_params.push(name::set(name));
			_params.push(email::set(email));
			Create::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_params,
			)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where.into(),
				_params,
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where,
				_params,
			)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(name, email, mut _params): (String, String, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(name::set(name));
			_params.push(email::set(email));
			Upsert::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where.into(),
				_params,
				_update,
			)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where.into(),
				vec![],
			)
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where.into(),
			)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				vec![],
			)
		}
	}
}
pub mod _prisma {
	pub struct PrismaClient {
		executor: ::prisma_client_rust::Executor,
		query_schema: ::std::sync::Arc<::prisma_client_rust::schema::QuerySchema>,
		url: String,
	}
	impl ::std::fmt::Debug for PrismaClient {
		fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
			f.debug_struct("PrismaClient").finish()
		}
	}
	impl PrismaClient {
		pub(super) fn _new_query_context(&self) -> ::prisma_client_rust::queries::QueryContext {
			::prisma_client_rust::queries::QueryContext::new(&self.executor, &self.query_schema)
		}
		pub(super) fn _new(
			executor: ::prisma_client_rust::Executor,
			query_schema: std::sync::Arc<::prisma_client_rust::schema::QuerySchema>,
			url: String,
		) -> Self {
			Self {
				executor,
				query_schema,
				url,
			}
		}
		pub fn _query_raw<T: serde::de::DeserializeOwned>(
			&self,
			query: ::prisma_client_rust::raw::Raw,
		) -> ::prisma_client_rust::QueryRaw<T> {
			::prisma_client_rust::QueryRaw::new(
				::prisma_client_rust::queries::QueryContext::new(
					&self.executor,
					&self.query_schema,
				),
				query,
				super::DATABASE_STR,
			)
		}
		pub fn _execute_raw(
			&self,
			query: ::prisma_client_rust::raw::Raw,
		) -> ::prisma_client_rust::ExecuteRaw {
			::prisma_client_rust::ExecuteRaw::new(
				::prisma_client_rust::queries::QueryContext::new(
					&self.executor,
					&self.query_schema,
				),
				query,
				super::DATABASE_STR,
			)
		}
		pub async fn _batch<T: ::prisma_client_rust::BatchContainer<Marker>, Marker>(
			&self,
			queries: T,
		) -> ::prisma_client_rust::queries::Result<T::ReturnType> {
			::prisma_client_rust::batch(queries, &self.executor, &self.query_schema).await
		}
		pub async fn _migrate_deploy(
			&self,
		) -> Result<(), ::prisma_client_rust::migrations::MigrateDeployError> {
			let res = ::prisma_client_rust::migrations::migrate_deploy(
				super::DATAMODEL_STR,
				super::MIGRATIONS_DIR,
				&self.url,
			)
			.await;
			tokio::time::sleep(core::time::Duration::from_millis(1)).await;
			res
		}
		pub async fn _migrate_resolve(
			&self,
			migration: &str,
		) -> Result<(), ::prisma_client_rust::migrations::MigrateResolveError> {
			::prisma_client_rust::migrations::migrate_resolve(
				migration,
				super::DATAMODEL_STR,
				super::MIGRATIONS_DIR,
				&self.url,
			)
			.await
		}
		pub fn _db_push(&self) -> ::prisma_client_rust::migrations::DbPush {
			::prisma_client_rust::migrations::db_push(super::DATAMODEL_STR, &self.url)
		}
		pub fn user(&self) -> super::user::Actions {
			super::user::Actions { client: &self }
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum SortOrder {
		#[serde(rename = "asc")]
		Asc,
		#[serde(rename = "desc")]
		Desc,
	}
	impl ToString for SortOrder {
		fn to_string(&self) -> String {
			match self {
				Self::Asc => "asc".to_string(),
				Self::Desc => "desc".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum TransactionIsolationLevel {
		#[serde(rename = "Serializable")]
		Serializable,
	}
	impl ToString for TransactionIsolationLevel {
		fn to_string(&self) -> String {
			match self {
				Self::Serializable => "Serializable".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum UserScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "email")]
		Email,
	}
	impl ToString for UserScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Name => "name".to_string(),
				Self::Email => "email".to_string(),
			}
		}
	}
}
pub use _prisma::PrismaClient;
