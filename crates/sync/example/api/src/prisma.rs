// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
pub static DATAMODEL_STR : & 'static str = include_str ! ("/Users/brendonovich/github.com/spacedriveapp/spacedrive/crates/sync/example/prisma/schema.prisma") ;
static DATABASE_STR: &'static str = "sqlite";
use ::prisma_client_rust::migrations::include_dir;
pub static MIGRATIONS_DIR: &::prisma_client_rust::migrations::include_dir::Dir = &::prisma_client_rust::migrations::include_dir::include_dir!(
	"/Users/brendonovich/github.com/spacedriveapp/spacedrive/crates/sync/example/prisma/migrations"
);
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
	url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	PrismaClient::_builder()
		.with_url(url.to_string())
		.build()
		.await
}
pub mod file_path {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BytesFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BytesFilter::NotInVec(value))
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BytesFilter::Not(value))
		}
		pub struct Set(pub Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
	}
	pub mod path {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::PathEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Path(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Path(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Path(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Path(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Path(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Path(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Path(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Path(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Path(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Path(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Path(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetPath(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Path(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("path").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Path(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("path").build()
			}
		}
	}
	pub mod object {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Object(fetch.0)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectObject
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectObject(value.0)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("object");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						let mut nested_selections = < object :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch => {
						selection . nested_selections (< object :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("object");
				match self {
					Self::Select(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(selections) => {
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch => {
						selection . nested_selections (< object :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod object_id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::ObjectIdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::ObjectId(direction)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::BytesFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::BytesFilter::NotInVec(value))
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::BytesFilter::Not(value))
		}
		pub struct Set(pub Option<Vec<u8>>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetObjectId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("object_id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("object_id").build()
			}
		}
	}
	pub fn create(
		id: Vec<u8>,
		path: String,
		_params: Vec<SetParam>,
	) -> (Vec<u8>, String, Vec<SetParam>) {
		(id, path, _params)
	}
	pub fn create_unchecked(
		id: Vec<u8>,
		path: String,
		_params: Vec<SetParam>,
	) -> (Vec<u8>, String, Vec<SetParam>) {
		(id, path, _params)
	}
	#[macro_export]
	macro_rules ! _select_file_path { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: file_path :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: file_path :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: file_path :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: file_path :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: file_path :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: file_path :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , path , object , object_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: file_path :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: file_path :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: file_path :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: file_path :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: file_path :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: file_path :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "path" , "object" , "object_id"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [$ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: file_path :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: file_path :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { Vec < u8 > } ; (@ field_type ; path) => { String } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < object :: Data > } ; (@ field_type ; object) => { Option < crate :: prisma :: object :: Data > } ; (@ field_type ; object_id) => { Option < Vec < u8 > > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "FilePath" , available fields are "id, path, object, object_id")) } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: object :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: file_path :: SelectParam > :: into ($ crate :: prisma :: file_path :: id :: Select) } ; (@ selection_field_to_selection_param ; path) => { Into :: < $ crate :: prisma :: file_path :: SelectParam > :: into ($ crate :: prisma :: file_path :: path :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: file_path :: SelectParam > :: into ($ crate :: prisma :: file_path :: object :: Select :: $ selection_mode ($ crate :: prisma :: object :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: file_path :: SelectParam > :: into ($ crate :: prisma :: file_path :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; object_id) => { Into :: < $ crate :: prisma :: file_path :: SelectParam > :: into ($ crate :: prisma :: file_path :: object_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: file_path :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; object) => { "object" } ; (@ field_serde_name ; object_id) => { "object_id" } ; }
	pub use _select_file_path as select;
	pub enum SelectParam {
		Id(id::Select),
		Path(path::Select),
		Object(object::Select),
		ObjectId(object_id::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Path(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_file_path { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: file_path :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: file_path :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: file_path :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: file_path :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: file_path :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: file_path :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: file_path :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: file_path :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : Vec < u8 > , pub path : String , pub object_id : Option < Vec < u8 > > , $ (pub $ field : $ crate :: prisma :: file_path :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (path) , stringify ! (object_id)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; path) , & self . path) ? ; state . serialize_field ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; object_id) , & self . object_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , path , object_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: file_path :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: file_path :: include ! (@ field_serde_name ; path) , ", " , $ crate :: prisma :: file_path :: include ! (@ field_serde_name ; object_id) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: file_path :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: file_path :: include ! (@ field_serde_name ; path) => Ok (Field :: path) , $ crate :: prisma :: file_path :: include ! (@ field_serde_name ; object_id) => Ok (Field :: object_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut path = None ; let mut object_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: path => { if path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; path))) ; } path = Some (map . next_value () ?) ; } Field :: object_id => { if object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; object_id))) ; } object_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; id))) ? ; let path = path . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; path))) ? ; let object_id = object_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: file_path :: include ! (@ field_serde_name ; object_id))) ? ; Ok (Data { id , path , object_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "path" , "object" , "object_id"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (id) . to_string () , optional : false , ty : < Vec < u8 > as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (path) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (object_id) . to_string () , optional : false , ty : < Option < Vec < u8 > > as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , $ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: file_path :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: file_path :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < object :: Data > } ; (@ field_type ; object) => { Option < crate :: prisma :: object :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FilePath" , available relations are "object")) } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: object :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: file_path :: IncludeParam > :: into ($ crate :: prisma :: file_path :: object :: Include :: $ selection_mode ($ crate :: prisma :: object :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: file_path :: IncludeParam > :: into ($ crate :: prisma :: file_path :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: file_path :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; object) => { "object" } ; (@ field_serde_name ; object_id) => { "object_id" } ; }
	pub use _include_file_path as include;
	pub enum IncludeParam {
		Id(id::Include),
		Path(path::Include),
		Object(object::Include),
		ObjectId(object_id::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Path(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
			}
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: rspc :: Type,
	)]
	#[specta(
		rename = "FilePath",
		crate = "prisma_client_rust::rspc::internal::specta"
	)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: Vec<u8>,
		#[serde(rename = "path")]
		pub path: String,
		#[serde(
			rename = "object",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub object: Option<Option<Box<super::object::Data>>>,
		#[serde(rename = "object_id")]
		pub object_id: Option<Vec<u8>>,
	}
	impl Data {
		pub fn object(
			&self,
		) -> Result<Option<&super::object::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Object(super::object::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Object(args) => {
					let mut selections = < super :: object :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					let mut builder = ::prisma_client_rust::Selection::builder("object");
					builder.nested_selections(selections);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(Vec<u8>),
		SetPath(String),
		ConnectObject(super::object::UniqueWhereParam),
		DisconnectObject,
		SetObjectId(Option<Vec<u8>>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Bytes(value),
				),
				SetParam::SetPath(value) => (
					"path".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::ConnectObject(where_param) => (
					"object".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectObject => (
					"object".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
				SetParam::SetObjectId(value) => (
					"object_id".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
						.unwrap_or(::prisma_client_rust::PrismaValue::Null),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(::prisma_client_rust::Direction),
		Path(::prisma_client_rust::Direction),
		ObjectId(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Id(direction) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Path(direction) => (
					"path".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::ObjectId(direction) => (
					"object_id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(Vec<u8>),
		Id(_prisma::read_filters::BytesFilter),
		PathEquals(String),
		Path(_prisma::read_filters::StringFilter),
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
		ObjectIdEquals(Option<Vec<u8>>),
		ObjectId(_prisma::read_filters::BytesFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::IdEquals(value) => (
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Bytes(value),
					)]),
				),
				Self::Id(value) => ("id", value.into()),
				Self::PathEquals(value) => (
					"path",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Path(value) => ("path", value.into()),
				Self::ObjectIs(where_params) => (
					"object",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					"object",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIdEquals(value) => (
					"object_id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
							.unwrap_or(::prisma_client_rust::PrismaValue::Null),
					)]),
				),
				Self::ObjectId(value) => ("object_id", value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(Vec<u8>),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "FilePath";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			["id", "path", "object_id"]
				.into_iter()
				.map(|o| {
					let builder = ::prisma_client_rust::Selection::builder(o);
					builder.build()
				})
				.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(self, id: Vec<u8>, path: String, mut _params: Vec<SetParam>) -> Create<'a> {
			_params.push(id::set(id));
			_params.push(path::set(path));
			Create::new(self.client, _params)
		}
		pub fn create_many(self, data: Vec<(Vec<u8>, String, Vec<SetParam>)>) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(id, path, mut _params)| {
					_params.push(id::set(id));
					_params.push(path::set(path));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(id, path, mut _params): (Vec<u8>, String, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(id::set(id));
			_params.push(path::set(path));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod object {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BytesFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<Vec<u8>>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BytesFilter::NotInVec(value))
		}
		pub fn not(value: Vec<u8>) -> WhereParam {
			WhereParam::Id(_prisma::read_filters::BytesFilter::Not(value))
		}
		pub struct Set(pub Vec<u8>);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
	}
	pub mod name {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals(value: String) -> WhereParam {
			WhereParam::NameEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Name(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(value))
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Contains(value))
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(value))
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(value))
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetName(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("name").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("name").build()
			}
		}
	}
	pub mod paths {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn some(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::PathsSome(value)
		}
		pub fn every(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::PathsEvery(value)
		}
		pub fn none(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::PathsNone(value)
		}
		pub struct Fetch(pub file_path::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<file_path::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: file_path::OrderByParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: file_path::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(fetch: Fetch) -> Self {
				WithParam::Paths(fetch.0)
			}
		}
		pub fn fetch(params: Vec<file_path::WhereParam>) -> Fetch {
			Fetch(file_path::ManyArgs::new(params))
		}
		pub fn connect<T: From<Connect>>(params: Vec<file_path::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectPaths(params)
		}
		pub fn set(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::SetPaths(params)
		}
		pub struct Connect(pub Vec<file_path::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(value: Connect) -> Self {
				Self::ConnectPaths(value.0)
			}
		}
		pub enum Include {
			Select(file_path::ManyArgs, Vec<file_path::SelectParam>),
			Include(file_path::ManyArgs, Vec<file_path::IncludeParam>),
			Fetch(file_path::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Paths(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("paths");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						let mut nested_selections = < file_path :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						selection.nested_selections(nested_selections);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< file_path :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Select {
			Select(file_path::ManyArgs, Vec<file_path::SelectParam>),
			Include(file_path::ManyArgs, Vec<file_path::IncludeParam>),
			Fetch(file_path::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Paths(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let mut selection = ::prisma_client_rust::Selection::builder("paths");
				match self {
					Self::Select(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Include(args, selections) => {
						selection.set_arguments(args.to_graphql().0);
						selection.nested_selections(
							selections.into_iter().map(|s| s.to_selection()).collect(),
						);
					}
					Self::Fetch(args) => {
						selection.set_arguments(args.to_graphql().0);
						selection . nested_selections (< file_path :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					}
				}
				selection.build()
			}
			pub fn select(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub fn create(
		id: Vec<u8>,
		name: String,
		_params: Vec<SetParam>,
	) -> (Vec<u8>, String, Vec<SetParam>) {
		(id, name, _params)
	}
	pub fn create_unchecked(
		id: Vec<u8>,
		name: String,
		_params: Vec<SetParam>,
	) -> (Vec<u8>, String, Vec<SetParam>) {
		(id, name, _params)
	}
	#[macro_export]
	macro_rules ! _select_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: object :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: object :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: object :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: object :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , paths } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: object :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: object :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: object :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: object :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: object :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: object :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "paths"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [$ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: object :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: object :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { Vec < u8 > } ; (@ field_type ; name) => { String } ; (@ field_type ; paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < paths :: Data > } ; (@ field_type ; paths) => { Vec < crate :: prisma :: file_path :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Object" , available fields are "id, name, paths")) } ; (@ field_module ; paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: file_path :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: object :: SelectParam > :: into ($ crate :: prisma :: object :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: object :: SelectParam > :: into ($ crate :: prisma :: object :: name :: Select) } ; (@ selection_field_to_selection_param ; paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: object :: SelectParam > :: into ($ crate :: prisma :: object :: paths :: Select :: $ selection_mode ($ crate :: prisma :: file_path :: ManyArgs :: new ($ crate :: prisma :: file_path :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: file_path :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: object :: SelectParam > :: into ($ crate :: prisma :: object :: paths :: Select :: Fetch ($ crate :: prisma :: file_path :: ManyArgs :: new ($ crate :: prisma :: file_path :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; paths) => { "paths" } ; }
	pub use _select_object as select;
	pub enum SelectParam {
		Id(id::Select),
		Name(name::Select),
		Paths(paths::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Paths(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: object :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: object :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: object :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: object :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: object :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: object :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { paths } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : Vec < u8 > , pub name : String , $ (pub $ field : $ crate :: prisma :: object :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: object :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: object :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: object :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: object :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: object :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: object :: include ! (@ field_serde_name ; name) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: object :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: object :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: object :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: object :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: object :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: object :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: object :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: object :: include ! (@ field_serde_name ; id))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: object :: include ! (@ field_serde_name ; name))) ? ; Ok (Data { id , name , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "paths"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } impl prisma_client_rust :: rspc :: internal :: specta :: Type for Data { const NAME : & 'static str = "Data" ; fn inline (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { prisma_client_rust :: rspc :: internal :: specta :: DataType :: Object (prisma_client_rust :: rspc :: internal :: specta :: ObjectType { name : "Data" . to_string () , tag : None , generics : vec ! [] , fields : vec ! [prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (id) . to_string () , optional : false , ty : < Vec < u8 > as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! (name) . to_string () , optional : false , ty : < String as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) } , $ (prisma_client_rust :: rspc :: internal :: specta :: ObjectField { name : stringify ! ($ field) . to_string () , optional : false , ty : < $ crate :: prisma :: object :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) as prisma_client_rust :: rspc :: internal :: specta :: Type > :: reference (prisma_client_rust :: rspc :: internal :: specta :: DefOpts { parent_inline : false , type_map : _opts . type_map } , & []) }) , *] , type_id : None }) } fn reference (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts , _ : & [prisma_client_rust :: rspc :: internal :: specta :: DataType]) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { Self :: inline (_opts , & []) } fn definition (_opts : prisma_client_rust :: rspc :: internal :: specta :: DefOpts) -> prisma_client_rust :: rspc :: internal :: specta :: DataType { unreachable ! () } } $ ($ (pub mod $ field { $ crate :: prisma :: object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < paths :: Data > } ; (@ field_type ; paths) => { Vec < crate :: prisma :: file_path :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Object" , available relations are "paths")) } ; (@ field_module ; paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: file_path :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: object :: IncludeParam > :: into ($ crate :: prisma :: object :: paths :: Include :: $ selection_mode ($ crate :: prisma :: file_path :: ManyArgs :: new ($ crate :: prisma :: file_path :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: file_path :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: object :: IncludeParam > :: into ($ crate :: prisma :: object :: paths :: Include :: Fetch ($ crate :: prisma :: file_path :: ManyArgs :: new ($ crate :: prisma :: file_path :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; paths) => { "paths" } ; }
	pub use _include_object as include;
	pub enum IncludeParam {
		Id(id::Include),
		Name(name::Include),
		Paths(paths::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Paths(data) => data.to_selection(),
			}
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: rspc :: Type,
	)]
	#[specta(
		rename = "Object",
		crate = "prisma_client_rust::rspc::internal::specta"
	)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: Vec<u8>,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "paths")]
		#[specta(skip)]
		pub paths: Option<Vec<super::file_path::Data>>,
	}
	impl Data {
		pub fn paths(
			&self,
		) -> Result<&Vec<super::file_path::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.paths
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(paths),
				))
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Paths(super::file_path::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Paths(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: file_path :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
					let mut builder = ::prisma_client_rust::Selection::builder("paths");
					builder
						.nested_selections(nested_selections)
						.set_arguments(arguments);
					builder.build()
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(Vec<u8>),
		SetName(String),
		ConnectPaths(Vec<super::file_path::UniqueWhereParam>),
		DisconnectPaths(Vec<super::file_path::UniqueWhereParam>),
		SetPaths(Vec<super::file_path::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Bytes(value),
				),
				SetParam::SetName(value) => (
					"name".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
				SetParam::ConnectPaths(where_params) => (
					"paths".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::DisconnectPaths(where_params) => (
					"paths".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				SetParam::SetPaths(where_params) => (
					"paths".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(::prisma_client_rust::Direction),
		Name(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Id(direction) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Name(direction) => (
					"name".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(Vec<u8>),
		Id(_prisma::read_filters::BytesFilter),
		NameEquals(String),
		Name(_prisma::read_filters::StringFilter),
		PathsSome(Vec<super::file_path::WhereParam>),
		PathsEvery(Vec<super::file_path::WhereParam>),
		PathsNone(Vec<super::file_path::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::IdEquals(value) => (
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Bytes(value),
					)]),
				),
				Self::Id(value) => ("id", value.into()),
				Self::NameEquals(value) => (
					"name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::Name(value) => ("name", value.into()),
				Self::PathsSome(where_params) => (
					"paths",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::PathsEvery(where_params) => (
					"paths",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::PathsNone(where_params) => (
					"paths",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name, value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(Vec<u8>),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
	pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
	pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl ::prisma_client_rust::ModelActions for Actions<'_> {
		type Data = Data;
		type Where = WhereParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = "Object";
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			["id", "name"]
				.into_iter()
				.map(|o| {
					let builder = ::prisma_client_rust::Selection::builder(o);
					builder.build()
				})
				.collect()
		}
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(self.client, _where)
		}
		pub fn create(self, id: Vec<u8>, name: String, mut _params: Vec<SetParam>) -> Create<'a> {
			_params.push(id::set(id));
			_params.push(name::set(name));
			Create::new(self.client, _params)
		}
		pub fn create_many(self, data: Vec<(Vec<u8>, String, Vec<SetParam>)>) -> CreateMany<'a> {
			let data = data
				.into_iter()
				.map(|(id, name, mut _params)| {
					_params.push(id::set(id));
					_params.push(name::set(name));
					_params
				})
				.collect();
			CreateMany::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(id, name, mut _params): (Vec<u8>, String, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(id::set(id));
			_params.push(name::set(name));
			Upsert::new(self.client, _where.into(), _params, _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(self.client, _where)
		}
	}
}
pub mod _prisma {
	pub struct PrismaClientBuilder {
		url: Option<String>,
		action_notifier: ::prisma_client_rust::ActionNotifier,
	}
	impl PrismaClientBuilder {
		pub fn new() -> Self {
			Self {
				url: None,
				action_notifier: ::prisma_client_rust::ActionNotifier::new(),
			}
		}
		pub fn with_url(mut self, url: String) -> Self {
			self.url = Some(url);
			self
		}
		pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
			let config =
				::prisma_client_rust::datamodel::parse_configuration(super::DATAMODEL_STR)?.subject;
			let source = config
				.datasources
				.first()
				.expect("Please supply a datasource in your schema.prisma file");
			let url = match self.url {
				Some(url) => url,
				None => {
					if let Some(url) = source.load_shadow_database_url()? {
						url
					} else {
						source.load_url(|key| std::env::var(key).ok())?
					}
				}
			};
			let url = match url.starts_with("file:") {
				true => {
					let path = url.split(":").nth(1).unwrap();
					if std::path::Path::new("./prisma/schema.prisma").exists() {
						format!("file:./prisma/{}", path)
					} else {
						url
					}
				}
				_ => url,
			};
			let (db_name, executor) =
				::prisma_client_rust::query_core::executor::load(&source, &[], &url).await?;
			let internal_model =
				::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(
					super::DATAMODEL_STR,
				)
				.build(db_name);
			let query_schema =
				std::sync::Arc::new(prisma_client_rust::query_core::schema_builder::build(
					internal_model,
					true,
					source.capabilities(),
					vec![],
					source.referential_integrity(),
				));
			executor.primary_connector().get_connection().await?;
			Ok(PrismaClient(::prisma_client_rust::PrismaClientInternals {
				executor,
				query_schema,
				url,
				action_notifier: self.action_notifier,
			}))
		}
	}
	pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
	impl ::std::fmt::Debug for PrismaClient {
		fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
			f.debug_struct("PrismaClient").finish()
		}
	}
	impl PrismaClient {
		pub fn _builder() -> PrismaClientBuilder {
			PrismaClientBuilder::new()
		}
		pub fn _query_raw<T: serde::de::DeserializeOwned>(
			&self,
			query: ::prisma_client_rust::Raw,
		) -> ::prisma_client_rust::QueryRaw<T> {
			::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
		}
		pub fn _execute_raw(
			&self,
			query: ::prisma_client_rust::Raw,
		) -> ::prisma_client_rust::ExecuteRaw {
			::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
		}
		pub async fn _batch<T: ::prisma_client_rust::BatchContainer<Marker>, Marker>(
			&self,
			queries: T,
		) -> ::prisma_client_rust::Result<T::ReturnType> {
			::prisma_client_rust::batch(queries, &self.0).await
		}
		pub async fn _migrate_deploy(
			&self,
		) -> Result<(), ::prisma_client_rust::migrations::MigrateDeployError> {
			let res = ::prisma_client_rust::migrations::migrate_deploy(
				super::DATAMODEL_STR,
				super::MIGRATIONS_DIR,
				&self.0.url,
			)
			.await;
			::prisma_client_rust::tokio::time::sleep(core::time::Duration::from_millis(1)).await;
			res
		}
		pub async fn _migrate_resolve(
			&self,
			migration: &str,
		) -> Result<(), ::prisma_client_rust::migrations::MigrateResolveError> {
			::prisma_client_rust::migrations::migrate_resolve(
				migration,
				super::DATAMODEL_STR,
				super::MIGRATIONS_DIR,
				&self.0.url,
			)
			.await
		}
		pub fn _db_push(&self) -> ::prisma_client_rust::migrations::DbPush {
			::prisma_client_rust::migrations::db_push(super::DATAMODEL_STR, &self.0.url)
		}
		pub fn file_path(&self) -> super::file_path::Actions {
			super::file_path::Actions { client: &self.0 }
		}
		pub fn object(&self) -> super::object::Actions {
			super::object::Actions { client: &self.0 }
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum FilePathScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "path")]
		Path,
		#[serde(rename = "object_id")]
		ObjectId,
	}
	impl ToString for FilePathScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Path => "path".to_string(),
				Self::ObjectId => "object_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum ObjectScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "name")]
		Name,
	}
	impl ToString for ObjectScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Name => "name".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum SortOrder {
		#[serde(rename = "asc")]
		Asc,
		#[serde(rename = "desc")]
		Desc,
	}
	impl ToString for SortOrder {
		fn to_string(&self) -> String {
			match self {
				Self::Asc => "asc".to_string(),
				Self::Desc => "desc".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum TransactionIsolationLevel {
		#[serde(rename = "Serializable")]
		Serializable,
	}
	impl ToString for TransactionIsolationLevel {
		fn to_string(&self) -> String {
			match self {
				Self::Serializable => "Serializable".to_string(),
			}
		}
	}
	pub mod read_filters {
		use super::*;
		#[derive(Clone)]
		pub enum BytesFilter {
			InVec(Vec<Vec<u8>>),
			NotInVec(Vec<Vec<u8>>),
			Not(Vec<u8>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for BytesFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::Bytes(v))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::Bytes(v))
									.collect(),
							),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::Bytes(value),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum StringFilter {
			InVec(Vec<String>),
			NotInVec(Vec<String>),
			Lt(String),
			Lte(String),
			Gt(String),
			Gte(String),
			Contains(String),
			StartsWith(String),
			EndsWith(String),
			Not(String),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::String(v))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|v| ::prisma_client_rust::PrismaValue::String(v))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Contains(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"contains".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::StartsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"startsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::EndsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"endsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				}
			}
		}
	}
}
pub use _prisma::PrismaClient;
